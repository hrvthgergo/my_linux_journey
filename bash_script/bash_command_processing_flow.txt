intro
-----
to interpret commands bash follows the following process step-by-step, in order.

step1 - tokenization
--------------------
	- during tokenization shell reads its input for unquoted metacharacters and uses them to divide the command line into words, operators and comments(#).
	- definitions:
		- a token is either a word or an operator. tokens are separated by metacharacters.
		- words: a sequence of characters treated as a unit by the shell. words may not include unquoted metacharacters.
		- operators: a control operator or a redirection operator. operators contain at least one unquoted metacharacter.
		- control operators: a token that performs a control function. it is; 
			a newline or one of the following -> ‘||’, ‘&&’, ‘&’, ‘;’, ‘;;’, ‘;&’, ‘;;&’, ‘|’, ‘|&’, ‘(’, or ‘)’.
		- redirection operators: ‘<’, ‘>’, '<<‘, '>>', '2>', '2>>', '<&’, ‘>&’, ‘>|’, '<<-’, '<>'.
		- metacharacters: a character that, when unquoted, separates words; 
			space, tab, newline or one of the following characters: ‘|’, ‘&’, ‘;’, ‘(’, ‘)’, ‘<’, or ‘>’.

step2 - command identification
------------------------------
	- during command identification shell breaks the command line down into simple and compound commands.
	- definitions:
		- simple commands: are a set of words terminated by a control operator. the first word is the command name, subsequent words are taken as individual arguments (options and their values) to that command.
		- compound commands: these are bash’s programming constructs. they start with a reserved word and are terminated by the corresponding reserved word. compound commands are the shell programming language constructs, each construct begins with a reserved word or control operator and is terminated by a corresponding reserved word or operator.
		- reserved words: words that have special meaning to the shell, used to begin and end the shell’s compound commands, link -> https://www.gnu.org/software/bash/manual/html_node/Reserved-Words.html.

step3 - expansions
------------------
	- expansion is performed on the command line after it has been split into tokens and identified commands
	- link: https://www.gnu.org/software/bash/manual/html_node/Shell-Expansions.html
	- there are seven (+1) kinds of expansions. the processing order is;
		1) brace expansion
		2) tilde expansion, parameter and variable expansion, arithmetic expansion, and command substitution (done in a left-to-right fashion) (+1 process substitution);
		3) word splitting;
		4) filename expansion/globbing.
		- only brace expansion, word splitting, and filename expansion can increase the number of words of the expansion; other expansions expand a single word to a single word.
	- unfolding stories -> find examples and further details here bash_script/bash_as_programming_language.txt:
		- brace expansions -> {},
		- tilde expansion -> ~,
		- parameter and variable expansion -> $, ${},
		- arithmetic expansion -> $(()),
		- command substitution -> $(),
		- process substitution -> <(), >(),
		- word splitting: after processing the preceding expansions, the shell will try to split the results of unquoted parameter expansions, unquoted arithmetic expansions and unquoted command substitutions into individual words. mind the different word splitting result of $var and "$var".
		  ${IFS@Q} - bash will split a word using the characters stored in the IFS variable, which by default contains space, tab, and newline.
		- filename expansion/globbing: any word containing one of globbing characters is interpreted as a pattern, and replaced with a list of alphabetically-sorted filenames that match the pattern (if they exist)
			- globbing pattern characters: *, ?, [], [!]. can be extended -> shopt -s extglob.
				- symbol(pattern1 | ... | patternN) -> symbols are: ?, *. @, +, !.
